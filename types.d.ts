/**
* https://stackoverflow.com/questions/58434389/typescript-deep-keyof-of-a-nested-object
* Look at HsTablesSyncService.ts file in azure collector for examples how to use Paths Type
* The purpose of these types is to use them, to give us suggestions about the properties of the interfaces,
* and limit us to make typo mistakes.
*
*/
// Joins two types K and P into a string, with a dot (".") separator, if both are string or number types.
type Join<K, P> = K extends string | number ?
    P extends string | number ?     // If both K and P are strings or numbers, join them with a dot separator unless P is an empty string
    `${K}${"" extends P ? "" : "."}${P}`
    : never : never;  // If either K or P are not strings or numbers, return never.

// It's used to decrement a depth value in recursive types.
type Prev = [never, 0, 1, 2, 3, 4, ...0[]];

/**
 * Define Primitive types to be used later in Paths.
 * We use this approach because cds typer define a Key as export type Key<T> = T & { [key]?: true };
 * This is type intersection and TS recognize Key<string> as object.
 */
type PrimitiveTypes = string | number | boolean | bigint | symbol | null | undefined | Date;// We asume that Date is primiteType!

// It recursively traverses the object and builds paths with dot notation (e.g., "property.subproperty").
type Paths<T, D extends number = 4> = [D] extends [never] ? never :
    T extends PrimitiveTypes ? "" // If T is not an object, return an empty string (no paths).
    : // We are in case where T is object
    {
        [K in keyof T]-?: K extends string | number ? // If the key K is a string or number, build a string path.
        `${K}` | Join<K, Paths<T[K], Prev[D]>> // Concatenate the key K with the recursively generated path for T[K].
        : never // If K is not a string or number, return never.
    }[keyof T]

/**
* Present filter operators allowed in EntityFilterPredicate.
*/
type FilterOperators<TType> = {
    /**
     * Equals.
     */
    '='?: TType | null, // eq could be null
    /**
     * Greater than.
     */
    '>'?: TType, // less/greater than maybe should'nt allow to have null
    /**
     * Less than.
     */
    '<'?: TType, // less/greater than maybe should'nt allow to have null
    /**
     * Less than or equal.
     */
    '<='?: TType | null, // allow null
    /**
     * Greater than or equal.
     */
    '>='?: TType | null, // allow null
    /**
     * Not equal.
     */
    '!='?: TType | null, // allow null
    /**
     * IN operator. attr IN ('val1', 'val2', .., valF)
     */
    in?: Array<TType>, // in operator
    /**
     * NOT IN.
     */
    'not in'?: Array<TType>,
    /**
     * Like operator. Provide expression for matching sting.
     * @example
     * {like: 'TextStartsWith%'};
     * {like: '%TextContainsAtAnyPlace%'};
     * {like: '%TextEndsWith'};
     */
    like?: string, // like operator
    /**
     * NOT LIKE
     */
    'not like'?: string // like operator
}

/**
 * Present Filter Operators that could be execute on Entity association.
 * (Attribute that is of type object).
 * For Association Operators we support only = or !=  plus value null.
 */
type AssociationFilterOperators = Pick<FilterOperators<null>, "=" | "!=">;

/**
 * This type is returning us type of the specific path from T(class).
 * @example
 * interface LOB{
 *  lobName: string | null | undefined;
 *  cloud_id: string;
 *  createdDate: Date;
 *  deletedDate: Date | null | undefined;
 * }
 * 
 * interface VM {
 *  name: string;
 *  platform: "AWS" | "CCIR" | "GCP",
 *  platformId: string;
 *  syncDate: string;
 *  lob?: LOB | null | undefined;
 * }
 * const type_string: PathValue<VM2, "name">; // this is type string
 * const type_date: PathValue<VM2, "lob.createdDate">; // this is type Date
 * const type_LOB:PathValue<VM2, "lob">; // this is type LOB
 * const type_LOB_lobName:PathValue<VM2, "lob.lobName">; // this is type string | null | undefined
 * const type_LOB_deletedDate:PathValue<VM2, "lob.deletedDate">; // this is type Date | null | undefined
 */
type PathValue<T, Path extends string> =
    Path extends `${infer Head}.${infer Rest}`
    ? Head extends keyof T
    ? PathValue<NonNullable<T[Head]>, Rest> // NonNullable is important, otherwise optinal parms are skiped and return never as type.
    : never
    : Path extends keyof T
    ? T[Path] // NonNullable may be skipped here ? We want to know that specific attribute accept null vaue.
    : never;

/**
 * Present type for where filter that could be any of TEntity attribute plus any other KeyString records.
 * This type is utility way to define TypeSafe usage of where predicate based on TEntity attributes and list of available operators.
 * If any issues ocurred - try to see and investigate what query is generated by CDS QL plugin.
 * @example
 * interface LOB{
 *  lobName: string;
 *  cloud_id: string;
 * }
 * 
 * interface VM {
 *  name: string;
 *  platform: "AWS" | "CCIR" | "GCP",
 *  platformId: string;
 *  syncDate: string;
 *  lob: LOB;
 * }
 * 
 * Example 1: Filter by two attribute with logical AND
 * // This should generate filter for all VM that has platform=AWS AND syncDate > yeasterday
 * const filter: EntityFilterPredicate<VM> = {
 *  platform: 'AWS',
 *  syncDate: { ">": yestarday },
 * };
 * It should be the same as
 * const filter: EntityFilterPredicate<VM> = {
 *  platform: 'AWS',
 *  and:{
 *      syncDate: { ">": yestarday }
 *  }
 * };
 * 
 * Example 2: Filter with logical OR and complex operator
 * // platform='AWS' or (syncDate > yestarday and platform: 'GCP') ?
 * const filter: EntityFilterPredicate<VM> = {
 *  platform: 'AWS',
 *  or: {
 *      syncDate: { ">": yestarday },
 *      "and": {
 *          platform: 'GCP'
 *      }
 *  }
 * };
 * 
 * Example 3: Use association to filter
 * // This example present that we are good to use path expressions lob attribute, its name has to match some patern.(i.e word LOB and INTERNAL)
 * const filter: EntityFilterPredicate<VM> = {
 *  platform: 'AWS',
 *  syncDate: { ">": yestarday },
 *  "lob.lobName": {
 *      'like': '%INTERNAL%LOB%'
 *  }
 * };
 * 
 */
type EntityFilterPredicate<TEntity> = Partial<{ [K in Paths<TEntity>]:
    K extends keyof TEntity ? // When K is attribute (not a path)
    TEntity[K] extends Date ? // K is attribute (Date is exception) 
    string | FilterOperators<string> // Date is exception - we have to present it as string or FilterOperators<string> (eq, like, >, <, etc)
    : TEntity[K] extends object ? // K is still attribute, that is not Date, and it is not object.
    AssociationFilterOperators | null // So K is attribute of type object(i.e association). Then we need to return simple filter operators of this type. Object/association could be eq null or not null.
    : TEntity[K] | FilterOperators<TEntity[K]> // K is still attribute, but it is not object. Then K is simple type attribute(string, number, boolean, etc). When K is simple attribute - we return it as ValueType or all possible operators of its value type 'eq', >, <, in, like, etc...
    : PathValue<TEntity, K> | FilterOperators<PathValue<TEntity, K>>   // Final else K is not attribute at TEntity level - it is "path", so we need to return filters by its type. See PathValue<>
}> & { // Always we return "and"/"or" part
    and?: EntityFilterPredicate<TEntity>;
    or?: EntityFilterPredicate<TEntity>;
};